/*****
  command line parser -- generated by clig (Version: 1996-09-15)

  The command line parser `clig':
  (C) 1995 Harald Kirsch (kir@iitb.fhg.de)
*****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* mainly a hack to make things work on SUNOS with gcc */
extern double strtod(const char *, char **);
extern long int strtol(const char *, char **, int);

#include "cmdline.h"

char *Program;

/*@-null*/

static Cmdline cmd = {
  /***** -b: buffer size in kB */
  /* bsizeP = */ TRUE,
  /* bsize = */ 128,
  /* bsizeC = */ 1,
  /***** uninterpreted rest of command line */
  /* argc = */ 0,
  /* argv = */ (char**)0
};

/*@=null*/

/***** let LCLint run more smoothly */
/*@-predboolothers*/
/*@-boolops*/


/**********************************************************************/
int
getIntOpt(int argc, char **argv, int i, int *value, int force)
{
  char *end;

  if( ++i>=argc ) goto nothingFound;

  *value = (int)strtol(argv[i], &end, 10);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace(*end) ) end+=1;
  if( *end ) goto nothingFound;

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr, 
	  "%s: missing or malformed integer value after option `%s'\n",
	  Program, argv[i-1]);
    exit(EXIT_FAILURE);
}
/**********************************************************************/
int
getIntOpts(int argc, char **argv, int i, 
	   int **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = (int*)calloc((size_t)alloced, sizeof(int));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(int));
      if( !*values ) goto outMem;
    }

    (*values)[used] = (int)strtol(argv[used+i+1], &end, 10);

    /***** check for conversion error */
    if( end==argv[i] ) break;

    /***** check for surplus non-whitespace */
    while( isspace(*end) ) end+=1;
    if( *end ) break;
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be an "
	    "integer value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/
int
getFloatOpt(int argc, char **argv, int i, float *value, int force)
{
  char *end;

  if( ++i>=argc ) goto nothingFound;

  *value = (float)strtod(argv[i], &end);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace(*end) ) end+=1;
  if( *end ) goto nothingFound;

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr,
	  "%s: missing or malformed float value after option `%s'\n",
	  Program, argv[i-1]);
  exit(EXIT_FAILURE);
 
}
/**********************************************************************/
int
getFloatOpts(int argc, char **argv, int i, 
	   float **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = (float*)calloc((size_t)alloced, sizeof(float));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(float));
      if( !*values ) goto outMem;
    }

    (*values)[used] = (float)strtod(argv[used+i+1], &end);

    /***** check for conversion error */
    if( end==argv[i] ) break;

    /***** check for surplus non-whitespace */
    while( isspace(*end) ) end+=1;
    if( *end ) break;
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be a "
	    "floating-point value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/
int
getStringOpt(int argc, char **argv, int i, char **value, int force)
{
  if( ++i>=argc ) {
    fprintf(stderr, "%s: missing string after option `%s'\n",
            Program, argv[i-1]);
    exit(EXIT_FAILURE);
  }
  
  if( !force && argv[i+1][0] == '-' ) return i-1;
  *value = argv[i];
  return i;
}
/**********************************************************************/
int
getStringOpts(int argc, char **argv, int i, 
	   char*  **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  alloced = cmin + 4;
    
  *values = (char**)calloc((size_t)alloced, sizeof(char*));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory during parsing of option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(char*));
      if( !*values ) goto outMem;
    }

    if( argv[used+i+1][0]=='-' ) break;
    (*values)[used] = argv[used+i+1];
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
    "%s: less than %d parameters for option `%s', only %d found\n",
	    Program, cmin, argv[i], used);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/
void
checkIntLower(char *opt, int *values, int count, int max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%d\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
void
checkIntHigher(char *opt, int *values, int count, int min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%d\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
void
checkFloatLower(char *opt, float *values, int count, float max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%f\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/
void
checkFloatHigher(char *opt, float *values, int count, float min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%f\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
usage(void)
{
  fprintf(stderr, "\
usage: %s [-b bsize]\n\
    copy stdin to stderr while counting bytes and reporting progess\n\
  -b: buffer size in kB\n\
      1 integer value between 1 and oo\n\
      default: `128'\n\
", Program);
  exit(EXIT_FAILURE);
}
/**********************************************************************/

Cmdline *
parseCmdline(int argc, char **argv)
{
  int i, keep;

  Program = argv[0];
  for(i=1, cmd.argc=1; i<argc; i++) {
    if( 0==strcmp("-b", argv[i]) ) {
      cmd.bsizeP = TRUE;
      keep = i;
      i = getIntOpt(argc, argv, i, &cmd.bsize, 1);
      cmd.bsizeC = i-keep;
      checkIntHigher("-b", &cmd.bsize, cmd.bsizeC, 1);
      continue;
    }

    if( argv[i][0]=='-' ) {
      fprintf(stderr, "\n%s: unknown option `%s'\n\n",
              Program, argv[i]);
      usage();
    }
    argv[cmd.argc++] = argv[i];
  }/* for i */


  /*@-mustfree*/
  cmd.argv = argv+1;
  /*@=mustfree*/
  cmd.argc -= 1;

  if( cmd.argc>0 ) {
    fprintf(stderr, "%s: There are %d arguments not associated with any option\n",
            Program, cmd.argc);
    exit(EXIT_FAILURE);
  }
  /*@-compmempass*/  return &cmd;
}

